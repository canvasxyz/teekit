#!/bin/bash
set -euo pipefail

# Post-install script for kettle-vm-sgx
# Sets up users, directories, systemd services, and generates Gramine manifest.
# File copying (workerd, bundles, etc.) is done by mkosi.build using $DESTDIR.
# This script handles tasks that require mkosi-chroot (gramine tools, user creation).
# Note: This runs on the HOST with $BUILDROOT pointing to the target image.

echo "=== Post-install: kettle-vm-sgx ==="

# Define paths
SERVICE_DIR="$BUILDROOT/etc/systemd/system"
KETTLE_DIR="$BUILDROOT/opt/kettle"
KETTLE_LIB_DIR="$BUILDROOT/usr/lib/kettle"
AESMD_CONF="$BUILDROOT/etc/aesmd.conf"

# 1. Create kettle user and group in target image
echo "Creating kettle user..."
mkosi-chroot groupadd -r kettle || true  # May already exist
mkosi-chroot useradd -r -g kettle -d /var/lib/kettle -s /sbin/nologin kettle || true  # May already exist

# 2. Add kettle user to sgx groups for device access
echo "Adding kettle to sgx groups..."
mkosi-chroot groupadd -r sgx || true  # May already exist
mkosi-chroot usermod -a -G sgx kettle

# 2a. Add kettle user to sgx_prv group, normally created by linksgx.sh during aesmd startup
echo "Creating sgx_prv group for DCAP attestation..."
mkosi-chroot groupadd -r -g 1000 sgx_prv
mkosi-chroot usermod -a -G sgx_prv kettle
mkosi-chroot usermod -a -G sgx_prv aesmd

# 3. Ensure data directories exist and set ownership
echo "Setting up data directories..."
mkdir -p "$BUILDROOT/var/lib/kettle/do-storage"
mkdir -p "$BUILDROOT/etc/kettle"
mkosi-chroot chown -R kettle:kettle /var/lib/kettle
mkosi-chroot chown -R kettle:kettle /etc/kettle

# 4. Create /usr/lib/kettle directory for scripts and services
mkdir -p "$KETTLE_LIB_DIR"

# 5. Install systemd services
mkdir -p "$SERVICE_DIR"
echo "Installing systemd services..."
install -m 644 "$SRCDIR/kettle-vm-sgx/gramine-sgx.service" "$SERVICE_DIR/"

# 6. Install launcher scripts
echo "Installing launcher scripts..."
install -m 755 "$SRCDIR/kettle-vm-sgx/gramine-setup.sh" "$BUILDROOT/usr/bin/gramine-setup"
install -m 755 "$SRCDIR/kettle-vm-sgx/gramine-kettle-launcher.sh" "$BUILDROOT/usr/bin/gramine-kettle-launcher"

# 7. Copy cloud config scripts from base kettle-vm
echo "Installing cloud-launcher..."
install -m 755 "$SRCDIR/kettle-vm/cloud-launcher.sh" "$BUILDROOT/usr/bin/cloud-launcher"

# Copy cloud provider config scripts from scripts directory
echo "Installing cloud provider config scripts..."
install -m 755 "$SRCDIR/scripts/config_azure" "$KETTLE_LIB_DIR/"
install -m 755 "$SRCDIR/scripts/config_local" "$KETTLE_LIB_DIR/"
install -m 755 "$SRCDIR/scripts/config_gcp" "$KETTLE_LIB_DIR/"

# 7a. Install certbot-launcher (needed by certbot-launcher.service enabled below)
echo "Installing certbot-launcher..."
install -m 755 "$SRCDIR/kettle-vm/certbot-launcher.sh" "$BUILDROOT/usr/bin/certbot-launcher"

# 7b. Install SGX persistence scripts
# Unlike SEV-SNP which uses snpguest for sealing keys, SGX uses Gramine's built-in
# Protected File System (PFS) which encrypts /var/lib/kettle using MRENCLAVE-bound keys.
# We just need to sync the encrypted files to/from persistent storage across reboots.
echo "Installing sgx-persist..."
install -m 755 "$SRCDIR/kettle-vm-sgx/sgx-persist.sh" "$BUILDROOT/usr/bin/sgx-persist"

# 8. Install firewall script
echo "Installing firewall setup script..."
install -m 755 "$SRCDIR/kettle-vm/setup-firewall.sh" "$BUILDROOT/usr/bin/setup-firewall"

# 9. Copy cloud-launcher.service from kettle-vm
echo "Installing cloud-launcher.service..."
install -m 644 "$SRCDIR/kettle-vm/cloud-launcher.service" "$SERVICE_DIR/"

# 10. Copy firewall.service from kettle-vm
echo "Installing firewall.service..."
install -m 644 "$SRCDIR/kettle-vm/firewall.service" "$SERVICE_DIR/"

# 11. Copy certbot-launcher.service from kettle-vm
echo "Installing certbot-launcher.service..."
install -m 644 "$SRCDIR/kettle-vm/certbot-launcher.service" "$SERVICE_DIR/"

# 11a. Install sgx-persist.service for data persistence
echo "Installing sgx-persist.service..."
install -m 644 "$SRCDIR/kettle-vm-sgx/sgx-persist.service" "$SERVICE_DIR/"
# Periodic sync for crash safety (every 5 minutes)
install -m 644 "$SRCDIR/kettle-vm-sgx/sgx-persist-sync.service" "$SERVICE_DIR/"
install -m 644 "$SRCDIR/kettle-vm-sgx/sgx-persist.timer" "$SERVICE_DIR/"

# 12. Enable services using systemctl --root
echo "Enabling services..."
systemctl --root="$BUILDROOT" enable gramine-sgx.service
systemctl --root="$BUILDROOT" enable cloud-launcher.service
systemctl --root="$BUILDROOT" enable firewall.service
systemctl --root="$BUILDROOT" enable certbot-launcher.service
systemctl --root="$BUILDROOT" enable aesmd.service
# Enable persistent storage for SGX data
systemctl --root="$BUILDROOT" enable persistent-mount.service
systemctl --root="$BUILDROOT" enable sgx-persist.service
systemctl --root="$BUILDROOT" enable sgx-persist.timer

# 12a. Create systemd-tmpfiles configuration for SGX groups
# Ensure groups exist even if image build somehow missed them
echo "Creating systemd-tmpfiles configuration for SGX groups..."
mkdir -p "$BUILDROOT/usr/lib/tmpfiles.d"
cat > "$BUILDROOT/usr/lib/tmpfiles.d/sgx-groups.conf" << 'EOF'
# Ensure SGX groups exist before udev processes device rules
# This prevents "Unknown group 'sgx_prv'" errors during boot
g sgx_prv 1000 - - -
g sgx 996 - - -
EOF

# 12b. Configure AESM service ordering and retry logic
# With groups created during image build, this just ensures proper ordering.
echo "Configuring aesmd service dependencies..."
mkdir -p "$BUILDROOT/etc/systemd/system/aesmd.service.d"
cat > "$BUILDROOT/etc/systemd/system/aesmd.service.d/sgx-init.conf" << 'EOF'
[Unit]
# Ensure SGX devices are initialized before AESM starts
After=systemd-udev-settle.service

[Service]
Restart=on-failure
RestartSec=3
StartLimitBurst=2
EOF

# 13. Generate Gramine manifest and sign enclave
# Note: Files were already copied by mkosi.build to $DESTDIR (now in $BUILDROOT)
echo "Setting up Gramine enclave..."

# Verify required files exist (copied by mkosi.build)
if [ ! -f "$KETTLE_DIR/workerd" ]; then
    echo "ERROR: workerd not found at $KETTLE_DIR/workerd"
    echo "Ensure mkosi.build ran successfully"
    exit 1
fi
if [ ! -f "$KETTLE_DIR/workerd.manifest.template" ]; then
    echo "ERROR: workerd.manifest.template not found at $KETTLE_DIR"
    exit 1
fi

# Generate Gramine manifest inside the chroot (Go version, no Node.js)
echo "Generating Gramine manifest..."
mkosi-chroot sh -c "cd /opt/kettle && gramine-manifest \
    -Dlog_level=error \
    -Darch_libdir=/lib/x86_64-linux-gnu \
    -Dworkerd_bin=/opt/kettle/workerd \
    -Dkettle_bundle_dir=/opt/kettle \
    workerd.manifest.template workerd.manifest"
echo "Manifest generated: /opt/kettle/workerd.manifest"

# 14. Configure AESM for Azure SGX
echo "Configuring AESM (aesmd) service..."
cat > "$AESMD_CONF" << 'EOF'
# Azure SGX configuration
# Use Azure's DCAP Quote Provider
default quoting type = ecdsa_256
EOF

# 14a. Create ID enclave symlinks in AESM directory
# Required for DCAP attestation on some platforms (e.g., Debian)
echo "Creating ID enclave symlinks for AESM..."
AESM_DIR="$BUILDROOT/opt/intel/sgx-aesm-service/aesm"
if [ ! -d "$AESM_DIR" ]; then
    echo "WARNING: AESM directory not found at $AESM_DIR, skipping symlink creation"
elif [ ! -f "$BUILDROOT/usr/lib/x86_64-linux-gnu/libsgx_id_enclave.signed.so" ]; then
    echo "WARNING: ID enclave file not found, skipping symlink creation"
else
    mkosi-chroot ln -sf /usr/lib/x86_64-linux-gnu/libsgx_id_enclave.signed.so /opt/intel/sgx-aesm-service/aesm/libsgx_id_enclave.signed.so
    mkosi-chroot ln -sf /usr/lib/x86_64-linux-gnu/libsgx_id_enclave.signed.so.1 /opt/intel/sgx-aesm-service/aesm/libsgx_id_enclave.signed.so.1
    echo "ID enclave symlinks created"
fi

# Ensure workerd is on PATH for gramine-sgx launcher (it calls "workerd" by name).
echo "Creating /usr/local/bin/workerd symlink..."
mkdir -p "$BUILDROOT/usr/local/bin"
mkosi-chroot ln -sf /opt/kettle/workerd /usr/local/bin/workerd

# 15. Verify deterministic development signing key was copied by mkosi.build
echo "Verifying SGX signing key..."
if [ ! -f "$KETTLE_DIR/keys/enclave-key.pem" ]; then
    echo "ERROR: enclave-key.pem not found at $KETTLE_DIR/keys/"
    echo "       Key should have been copied by mkosi.build"
    exit 1
fi
echo "Using deterministic development signing key for reproducible builds"

# 16. Sign the enclave
echo "Signing SGX enclave..."
mkosi-chroot sh -c "cd /opt/kettle && gramine-sgx-sign \
    --manifest workerd.manifest \
    --key /opt/kettle/keys/enclave-key.pem \
    --output workerd.manifest.sgx"
echo "Enclave signed: /opt/kettle/workerd.manifest.sgx"

# 17. Extract MRENCLAVE for attestation
echo "Extracting MRENCLAVE..."
mkosi-chroot sh -c "cd /opt/kettle && gramine-sgx-sigstruct-view --output-format json workerd.sig > /opt/kettle/sigstruct.json"
# Extract just the MRENCLAVE value (run python inside chroot too)
mkosi-chroot sh -c "python3 -c \"import json; print(json.load(open('/opt/kettle/sigstruct.json'))['mr_enclave'])\" > /opt/kettle/mrenclave.txt"
MRENCLAVE=$(cat "$KETTLE_DIR/mrenclave.txt")
echo "MRENCLAVE: $MRENCLAVE"

# 18. Verify sgx-entrypoint was copied
if [ ! -f "$KETTLE_DIR/sgx-entrypoint" ]; then
    echo "ERROR: sgx-entrypoint (Go binary) missing in image at /opt/kettle/sgx-entrypoint"
    exit 1
fi
echo "Verified sgx-entrypoint binary: $(stat -c%s $KETTLE_DIR/sgx-entrypoint | numfmt --to=iec-i --suffix=B)"

# 19. Set ownership for kettle user
mkosi-chroot chown -R kettle:kettle /opt/kettle

# 20. Normalize timestamps for reproducibility
find "$KETTLE_DIR" -exec touch -t 197001010000.00 {} + 2>/dev/null || true
find "$KETTLE_LIB_DIR" -exec touch -t 197001010000.00 {} + 2>/dev/null || true

echo "=== Post-install complete ==="
